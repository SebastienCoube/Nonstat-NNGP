---
title: "Vignette objects and functions of the package"
output: html_document
---

This vignette gives a tour of the objects and functions of the package Bidart, reviewing the arguments of the functions and the contents of the objects. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Generate synthetic data
First, generate some synthetic data (heteroscedasticity of the latent field and the noise too)
```{r}
set.seed(1)
# Generate locations
locs = cbind(5*runif(3000), 5*runif(3000))
#Generate latent fields for the parameters
latent_field_noise =   GpGp::fast_Gp_sim(c(.5, 1, 1, 0), locs = locs)
latent_field_scale =   GpGp::fast_Gp_sim(c(.5, 1, 1, 0), locs = locs)
# set number of observations
n_obs = 2 * nrow(locs)
# observing with duplicates
observation_idx = c(sample(nrow(locs), nrow(locs) , replace =F), sample(nrow(locs), n_obs - nrow(locs) , replace =T))
observed_locs = locs[observation_idx,]
# covariates
X = as.data.frame(cbind(rbinom(n = n_obs, size = 1, prob = .5)))
colnames(X) = c("binomial")
X_noise = X
# regression coeffs
beta = c(100, 5)
beta_noise = c(-.5, 1)
# get logarithm of the parameters
log_noise_variance = as.matrix(cbind(1, X_noise)) %*% beta_noise + latent_field_noise[observation_idx]
log_scale = as.matrix(latent_field_scale[observation_idx])
# Use NNGP to generate data
NNarray = GpGp::find_ordered_nn(locs, 10) # Nearest Neighbor Array
sparse_chol = Bidart::compute_sparse_chol(covfun_name = "exponential_isotropic", range_beta = log(.1), locs = locs, NNarray = NNarray) # stationary covariance
# get latent NNGP field and observed Gaussian field
latent_field = GpGp::fast_Gp_sim_Linv(Linv = sparse_chol[[1]], NNarray = NNarray)
observed_field = as.vector(exp(.5*log_scale) * latent_field[observation_idx] +exp(.5*log_noise_variance)*rnorm(n_obs)+ cbind(1, as.matrix(X))%*%beta)
```


## Initialize the model


### Arguments

The model object is a *list* created with the function **Bidart::mcmc_nngp_initialize_nonstationary**
In order to initialize the model, you need : 

- **observed_locs**,  a *matrix* of spatial locations with *2* columns (yet).
- **observed_field**, a *vector* of observations done at observed_locs.
You need to have nrow(observed_locs) == length(observed field)

You can further indicate : 

- **covfun**, a *string* for the covariance function name. Takes the value "exponential_isotropic" by default (can be : "exponential_isotropic", "exponential_sphere", "exponential_spacetime", "exponential_spheretime", "exponential_anisotropic", "nonstationary_exponential_isotropic", "nonstationary_exponential_isotropic_sphere", "nonstationary_exponential_anisotropic", "nonstationary_exponential_anisotropic_sphere").
- **m**, an *integer* for the number of parents (by default 5).
- **reordering**, a *string* indicating the reordering. Takes the value "maxmin" by default (can be : "maxmin", "random", "coord", "dist_to_point", "middleout").
- **response_model**, a *string* indicating the data model (for now and by default, "Gaussian").
- **n_chains**, an *integer* indicating the number of MCMC chains (by default 3).
- **seed**, an *integer* giving the seed (by default 1).
- **X**, a *data.frame* of covariates to explain the observed variables (intercept is added automatically).
- **noise_X**, a *data.frame* of covariates to explain the heteroscedasticity of the noise (intercept is added automatically).
- **noise_range**, a *positive number*  to indicate the range of the log-NNGP prior for the noise variance (initializes a log-NNGP latent field for the noise variance).
- **scale_X**, a *data.frame* of covariates to explain the heteroscedasticity of the latent field. The covariates must be constant within a spatial location (intercept is added automatically). 
- **scale_range**, a *positive number*  to indicate the range of the log-NNGP prior for the latent field variance (initializes a log-NNGP latent field for the latent field variance).

If you indicated a nonstationary covariance function ("nonstationary_exponential_isotropic", "nonstationary_exponential_isotropic_sphere", "nonstationary_exponential_anisotropic", "nonstationary_exponential_anisotropic_sphere"), you need to precise  **either or both** : 

- **range_X**, a *data.frame* of covariates to explain the range of the latent field. The covariates must be constant within a spatial location (intercept is added automatically). 
- **range_range**, a *positive number*  to indicate the range of the log-NNGP prior for the latent field variance (initializes a log-NNGP or matrix log-NNGP latent field for the latent field range).

If you filled either noise_range, scale_range, or range_range, you need to precise : 

- **log_NNGP_matern_covfun**, a *string* indicating a covariance function of  the Mat√©rn family (can be :  "matern_isotropic",  "matern_sphere").
- if you want, you can indicate **log_NNGP_matern_smoothness**, a *positive number* for log_NNGP_matern_covfun (by default 1).

Here we go, initialize a model with heteroscedastic latent field  and noise. 
```{r}
mcmc_nngp_list_nonstat = Bidart::mcmc_nngp_initialize_nonstationary (
  observed_locs = observed_locs, #spatial locations
  observed_field = c(observed_field), # Response variable
  X = X, # Covariates for the observed field
  m = 10, #number of Nearest Neighbors
  reordering = c("maxmin"), #Reordering
  covfun = "exponential_isotropic", response_model = "Gaussian", # covariance model and response model
  noise_X = X_noise, # covariates for the noise
  noise_range = .5, # range for latent field of parameters, if NULL no latent field
  scale_X = NULL, # covariates for the scale
  scale_range = .5, # range for latent field of parameters, if NULL no latent field
  log_NNGP_matern_covfun = "matern_isotropic", # covariance function for the hyperpriors
  log_NNGP_matern_smoothness = 1, # covariance function for the hyperpriors
  n_chains = 3,  # number of MCMC chains
  seed = 10
)
names(mcmc_nngp_list_nonstat)
```
### What is there in the model ? 

#### **data** is a *list* containing the information about the observations. It contains : 

- **observed_locs**, the *matrix* of observed locations. 
- **observed field**, the *vector* of observations.
- **locs**, a *matrix* of duplicate-less, re-orderd locations. 
- **covariates**, a *list* about the covariates of the latent field, the covariates of the scale, noise, range (even if it is just an intercept).
```{r}
names(mcmc_nngp_list_nonstat$data)
names(mcmc_nngp_list_nonstat$data$covariates)
```

#### **hierarchical_model** is a *list* containing the information about the hierarchical model and its hyperpriors.  It contains : 

- **response_model** is a *string* indicating the response model (only "Gaussian" yet).
- **covfun** is a *string* indicating the covariance function.
- **hyperprior_covariance** is a *list* giving information about the log-GP and matrix log-GP priors. 

```{r}
names(mcmc_nngp_list_nonstat$hierarchical_model)
mcmc_nngp_list_nonstat$hierarchical_model$response_model
mcmc_nngp_list_nonstat$hierarchical_model$covfun
names(mcmc_nngp_list_nonstat$hierarchical_model$hyperprior_covariance)
```
#### **vecchia_approx** is a *list* containing the information about the NNGP graph. It contains  among others : 

- **NNarray**, the *matrix of integers* indicating the parents in the DAG (cf documentation of GpGP).
- **MRF_adjacency_mat**, a *sparse matrix* of adjacency for the moral graph.
- **coloring**, a *vector of integers* indicating the colors on the moral graph.
- **locs_match_matrix**, a *sparse matrix* matching un-duplicated locations  of locs and observations from observed_field possibly done at the same site.
The rest is ancillary objects derived from these and used as shortcuts. 

```{r}
names(mcmc_nngp_list_nonstat$vecchia_approx)
```


#### **states** is a *list* containing the information about the current state of each MCMC chain. 

There are n_chains elements in this list, each corresponding to a chain. 

- **params**, is a *list* gathering the chain parameters. 
- **sparse_chol_and_stuff**, is a *list* of ancillary objects derived from params.  
- **momenta**, is a *list* of the HMC momenta. 
- **transition_kernels**, is a *list* of Metropolis-Hastings or HMC parameters (such as proposal variance, leapfrog integration step...). 


```{r}
names(mcmc_nngp_list_nonstat$states$chain_1)
```

The rest is empty for now, we must run the model. 



## Run the model

### Arguments

In order to run the model, the function **Bidart::mcmc_nngp_run_nonstationary** takes the existing list, appends MCMC samples, and returns a new list. 

You need : 

- **mcmc_nngp_list**, the *list* containing the model. 

You can add computational options : 

- **n_cyles**, an *integer* indicating the number of MCMC cycles (by default 5)
- **n_iterations_update**, an *integer* greater than 50 indicating the number of MCMC iteration per cycle (by default 300)
- **n_cores**, an *integer* indicating the number of cores (by default min(n_chains, parallel::detectCores()-1))
- **thinning**, a *number*  between 0 and 1 indicating the proportion of kept iterations (by default 0.1)
- **field_n_chromatic**, an *integer* indicating the number of chromatic sweeps for the latent field (by default 3)
- **field_n_mala**, an *integer* indicating the number of HMC sweeps for the latent field (by default 1)


You can add some options about the diagnostic plots that pop up between MCMC cycles

- **plot_diags**, a *boolean* to indicate if diagnostics for high-level parameters must be plotted (by default T)
- **burn_in**, a *number* between 0 and 1 to discard the first iterations in order to propose the diagnostics  (by default 0.5)
- **plot_PSRF_fields**, a  *Boolean* to indicate if diagnostics must be plotted for the latent fields. Very costly. (by default F)
- **debug_outfile** = a file with messages from the parallel chains (by default "debug_mcmc_nngp.txt") 

```{r, fig.show='hide', results='hide'}
mcmc_nngp_list_nonstat = Bidart::mcmc_nngp_run_nonstationary(mcmc_nngp_list_nonstat, n_iterations_update = 100, n_cycles = 1, plot_diags = F)
```


## MCMC samples stored in the model

Now that we have run the model, we can look up the rest of mcmc_nngp_list. 


#### **Records** is a *list* containing the saved states of the MCMC chains. 

There are n_chains elements in this list, each corresponding to a chain. 
Each element is itself a *list* containing *arrays* of saved parameters. The arrays correspond to the model parameters from the "params" sub-list of each chain in "states". The two first dimensions of each arrays correspond to the original dimension of the parameters from "params". The samples are stacked along the third dimension. 

```{r}
names(mcmc_nngp_list_nonstat$records$chain_1)

# all MCMC samples of the first component of parameter beta
mcmc_nngp_list_nonstat$records$chain_1$beta[1,,]
# first MCMC samples of all components of parameter beta
mcmc_nngp_list_nonstat$records$chain_1$beta[,,1]
```

#### **iterations** is a *list* about the MCMC chain run. 


It has 2 elements : 

- **checkpoints** is a *matrix* that is updated at each MCMC cycle. Its first column corresponds to the iteration, its second column corresponds to the time in minutes. Its first row correspond to the time at the end of model initialization. 
- **thinning** is a *vector of integers* that indicates which iterations were kept. The i-th slice from the arrays of Records corresponds to the MCMC state at the i-th element of thinning. So here the first slice of the array of records corresponds to the 10-th iteration, the second to the 20-th, etc. 

```{r}
names(mcmc_nngp_list_nonstat$iterations)
mcmc_nngp_list_nonstat$iterations$checkpoints
mcmc_nngp_list_nonstat$iterations$thinning


```
## Prediction

### Arguments

In order to predict at unobserved locations, the function **Bidart::predict_latent_field** is used.

Its arguments are : 

- **mcmc_nngp_list**, a *list* corresponding to a fit model (diagnostic plots pop-up at each cycle).
- **predicted_locs**, a *matrix* of spatial locations where prediction needs to be done.
- **X_range_pred**, a *data.frame* of covariates for the range at the predicted locations if covariates were specified in mcmc_nngp_initialize_nonstationary (intercept is added automatically).
- **X_scale_pred**, a *data.frame* of covariates for the marginal variance at the predicted locations  if covariates were specified in mcmc_nngp_initialize_nonstationary (intercept is added automatically).
- **burn_in**, a *number between 0 and 1* indicating the proportion of MCMC samples to discard (by default 0.5).
- **n_cores**,  an *integer* indicating the number of cores.
- **predict_range**,  a *Boolean* indicating whether each linear and random effects of range must be returned, their sum being returned though (by default F).
- **predict_scale**,  a *Boolean* indicating whether each linear and random effects of marginal variance must be returned, their sum being returned though  (by default F).


Here is just an example, remember that the model is not properly fit.
```{r}
predicted_locs = as.matrix(expand.grid(seq(0, 5, .1), seq(0, 5, .1)))
pred = Bidart::predict_latent_field(mcmc_nngp_list = mcmc_nngp_list_nonstat, predicted_locs = predicted_locs, predict_scale = T)
```

### What is there in the prediction ? 


#### **predicted_samples** is a *list* containing the predictive MCMC samples.

It has n_chains elements, one for each chain. Each of those *lists* contains : 

- **field**, an *array* containing samples of the latent field stacked along the third dimension. 

If the range is nonstationary, it also contains : 

- **log_range**, an *array* containing samples of the log-range (or coordinates of the log range matrix) stacked along the third dimension. 
- if in addition predict_range == T, samples of each linear effect and the random effect are included. 

If the marginal variance of the latent field is nonstationary, it also contains : 

- **log_scale**, an *array* containing samples of the log-marginal variance stacked along the third dimension. 
- if in addition predict_scale == T, samples of each linear effect and the random effect are included. 


```{r}
names(pred$predicted_samples$chain_1)
```
#### **summaries** is a *list* containing *arrays* that summary the MCMC predictive samples.

Those arrays have depth 1, and are virtually matrices.
The statistics are stacked along the first dimension of the array. 

- The first row is the **mean**
- The second row is the **quandile 0.025**
- The third row is the **median**
- The fourth row is the **quandile 0.975**
- The fift row is the **standard deviation**


```{r}
pred$summaries$log_scale[,1:10,1]
```